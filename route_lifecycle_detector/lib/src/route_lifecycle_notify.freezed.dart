// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'route_lifecycle_notify.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$RouteLifecycleNotify {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotify);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RouteLifecycleNotify()';
}


}

/// @nodoc
class $RouteLifecycleNotifyCopyWith<$Res>  {
$RouteLifecycleNotifyCopyWith(RouteLifecycleNotify _, $Res Function(RouteLifecycleNotify) __);
}


/// Adds pattern-matching-related methods to [RouteLifecycleNotify].
extension RouteLifecycleNotifyPatterns on RouteLifecycleNotify {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( RouteLifecycleNotifyDidBackground value)?  didBackground,TResult Function( RouteLifecycleNotifyDidChangeTop value)?  didChangeTop,TResult Function( RouteLifecycleNotifyDidForeground value)?  didForeground,TResult Function( RouteLifecycleNotifyDidPop value)?  didPop,TResult Function( RouteLifecycleNotifyDidPush value)?  didPush,TResult Function( RouteLifecycleNotifyDidRemove value)?  didRemove,TResult Function( RouteLifecycleNotifyDidReplace value)?  didReplace,TResult Function( RouteLifecycleNotifyDidStartUserGesture value)?  didStartUserGesture,TResult Function( RouteLifecycleNotifyDidStopUserGesture value)?  didStopUserGesture,required TResult orElse(),}){
final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground() when didBackground != null:
return didBackground(_that);case RouteLifecycleNotifyDidChangeTop() when didChangeTop != null:
return didChangeTop(_that);case RouteLifecycleNotifyDidForeground() when didForeground != null:
return didForeground(_that);case RouteLifecycleNotifyDidPop() when didPop != null:
return didPop(_that);case RouteLifecycleNotifyDidPush() when didPush != null:
return didPush(_that);case RouteLifecycleNotifyDidRemove() when didRemove != null:
return didRemove(_that);case RouteLifecycleNotifyDidReplace() when didReplace != null:
return didReplace(_that);case RouteLifecycleNotifyDidStartUserGesture() when didStartUserGesture != null:
return didStartUserGesture(_that);case RouteLifecycleNotifyDidStopUserGesture() when didStopUserGesture != null:
return didStopUserGesture(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( RouteLifecycleNotifyDidBackground value)  didBackground,required TResult Function( RouteLifecycleNotifyDidChangeTop value)  didChangeTop,required TResult Function( RouteLifecycleNotifyDidForeground value)  didForeground,required TResult Function( RouteLifecycleNotifyDidPop value)  didPop,required TResult Function( RouteLifecycleNotifyDidPush value)  didPush,required TResult Function( RouteLifecycleNotifyDidRemove value)  didRemove,required TResult Function( RouteLifecycleNotifyDidReplace value)  didReplace,required TResult Function( RouteLifecycleNotifyDidStartUserGesture value)  didStartUserGesture,required TResult Function( RouteLifecycleNotifyDidStopUserGesture value)  didStopUserGesture,}){
final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground():
return didBackground(_that);case RouteLifecycleNotifyDidChangeTop():
return didChangeTop(_that);case RouteLifecycleNotifyDidForeground():
return didForeground(_that);case RouteLifecycleNotifyDidPop():
return didPop(_that);case RouteLifecycleNotifyDidPush():
return didPush(_that);case RouteLifecycleNotifyDidRemove():
return didRemove(_that);case RouteLifecycleNotifyDidReplace():
return didReplace(_that);case RouteLifecycleNotifyDidStartUserGesture():
return didStartUserGesture(_that);case RouteLifecycleNotifyDidStopUserGesture():
return didStopUserGesture(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( RouteLifecycleNotifyDidBackground value)?  didBackground,TResult? Function( RouteLifecycleNotifyDidChangeTop value)?  didChangeTop,TResult? Function( RouteLifecycleNotifyDidForeground value)?  didForeground,TResult? Function( RouteLifecycleNotifyDidPop value)?  didPop,TResult? Function( RouteLifecycleNotifyDidPush value)?  didPush,TResult? Function( RouteLifecycleNotifyDidRemove value)?  didRemove,TResult? Function( RouteLifecycleNotifyDidReplace value)?  didReplace,TResult? Function( RouteLifecycleNotifyDidStartUserGesture value)?  didStartUserGesture,TResult? Function( RouteLifecycleNotifyDidStopUserGesture value)?  didStopUserGesture,}){
final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground() when didBackground != null:
return didBackground(_that);case RouteLifecycleNotifyDidChangeTop() when didChangeTop != null:
return didChangeTop(_that);case RouteLifecycleNotifyDidForeground() when didForeground != null:
return didForeground(_that);case RouteLifecycleNotifyDidPop() when didPop != null:
return didPop(_that);case RouteLifecycleNotifyDidPush() when didPush != null:
return didPush(_that);case RouteLifecycleNotifyDidRemove() when didRemove != null:
return didRemove(_that);case RouteLifecycleNotifyDidReplace() when didReplace != null:
return didReplace(_that);case RouteLifecycleNotifyDidStartUserGesture() when didStartUserGesture != null:
return didStartUserGesture(_that);case RouteLifecycleNotifyDidStopUserGesture() when didStopUserGesture != null:
return didStopUserGesture(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  didBackground,TResult Function( Route<dynamic> topRoute,  Route<dynamic>? previousTopRoute)?  didChangeTop,TResult Function()?  didForeground,TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didPop,TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didPush,TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didRemove,TResult Function( Route<dynamic>? newRoute,  Route<dynamic>? oldRoute)?  didReplace,TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didStartUserGesture,TResult Function()?  didStopUserGesture,required TResult orElse(),}) {final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground() when didBackground != null:
return didBackground();case RouteLifecycleNotifyDidChangeTop() when didChangeTop != null:
return didChangeTop(_that.topRoute,_that.previousTopRoute);case RouteLifecycleNotifyDidForeground() when didForeground != null:
return didForeground();case RouteLifecycleNotifyDidPop() when didPop != null:
return didPop(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidPush() when didPush != null:
return didPush(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidRemove() when didRemove != null:
return didRemove(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidReplace() when didReplace != null:
return didReplace(_that.newRoute,_that.oldRoute);case RouteLifecycleNotifyDidStartUserGesture() when didStartUserGesture != null:
return didStartUserGesture(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidStopUserGesture() when didStopUserGesture != null:
return didStopUserGesture();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  didBackground,required TResult Function( Route<dynamic> topRoute,  Route<dynamic>? previousTopRoute)  didChangeTop,required TResult Function()  didForeground,required TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)  didPop,required TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)  didPush,required TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)  didRemove,required TResult Function( Route<dynamic>? newRoute,  Route<dynamic>? oldRoute)  didReplace,required TResult Function( Route<dynamic> route,  Route<dynamic>? previousRoute)  didStartUserGesture,required TResult Function()  didStopUserGesture,}) {final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground():
return didBackground();case RouteLifecycleNotifyDidChangeTop():
return didChangeTop(_that.topRoute,_that.previousTopRoute);case RouteLifecycleNotifyDidForeground():
return didForeground();case RouteLifecycleNotifyDidPop():
return didPop(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidPush():
return didPush(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidRemove():
return didRemove(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidReplace():
return didReplace(_that.newRoute,_that.oldRoute);case RouteLifecycleNotifyDidStartUserGesture():
return didStartUserGesture(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidStopUserGesture():
return didStopUserGesture();}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  didBackground,TResult? Function( Route<dynamic> topRoute,  Route<dynamic>? previousTopRoute)?  didChangeTop,TResult? Function()?  didForeground,TResult? Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didPop,TResult? Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didPush,TResult? Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didRemove,TResult? Function( Route<dynamic>? newRoute,  Route<dynamic>? oldRoute)?  didReplace,TResult? Function( Route<dynamic> route,  Route<dynamic>? previousRoute)?  didStartUserGesture,TResult? Function()?  didStopUserGesture,}) {final _that = this;
switch (_that) {
case RouteLifecycleNotifyDidBackground() when didBackground != null:
return didBackground();case RouteLifecycleNotifyDidChangeTop() when didChangeTop != null:
return didChangeTop(_that.topRoute,_that.previousTopRoute);case RouteLifecycleNotifyDidForeground() when didForeground != null:
return didForeground();case RouteLifecycleNotifyDidPop() when didPop != null:
return didPop(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidPush() when didPush != null:
return didPush(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidRemove() when didRemove != null:
return didRemove(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidReplace() when didReplace != null:
return didReplace(_that.newRoute,_that.oldRoute);case RouteLifecycleNotifyDidStartUserGesture() when didStartUserGesture != null:
return didStartUserGesture(_that.route,_that.previousRoute);case RouteLifecycleNotifyDidStopUserGesture() when didStopUserGesture != null:
return didStopUserGesture();case _:
  return null;

}
}

}

/// @nodoc


class RouteLifecycleNotifyDidBackground extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidBackground(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidBackground);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RouteLifecycleNotify.didBackground()';
}


}




/// @nodoc


class RouteLifecycleNotifyDidChangeTop extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidChangeTop({required this.topRoute, required this.previousTopRoute}): super._();
  

 final  Route<dynamic> topRoute;
 final  Route<dynamic>? previousTopRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidChangeTopCopyWith<RouteLifecycleNotifyDidChangeTop> get copyWith => _$RouteLifecycleNotifyDidChangeTopCopyWithImpl<RouteLifecycleNotifyDidChangeTop>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidChangeTop&&(identical(other.topRoute, topRoute) || other.topRoute == topRoute)&&(identical(other.previousTopRoute, previousTopRoute) || other.previousTopRoute == previousTopRoute));
}


@override
int get hashCode => Object.hash(runtimeType,topRoute,previousTopRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didChangeTop(topRoute: $topRoute, previousTopRoute: $previousTopRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidChangeTopCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidChangeTopCopyWith(RouteLifecycleNotifyDidChangeTop value, $Res Function(RouteLifecycleNotifyDidChangeTop) _then) = _$RouteLifecycleNotifyDidChangeTopCopyWithImpl;
@useResult
$Res call({
 Route<dynamic> topRoute, Route<dynamic>? previousTopRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidChangeTopCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidChangeTopCopyWith<$Res> {
  _$RouteLifecycleNotifyDidChangeTopCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidChangeTop _self;
  final $Res Function(RouteLifecycleNotifyDidChangeTop) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? topRoute = null,Object? previousTopRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidChangeTop(
topRoute: null == topRoute ? _self.topRoute : topRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>,previousTopRoute: freezed == previousTopRoute ? _self.previousTopRoute : previousTopRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidForeground extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidForeground(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidForeground);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RouteLifecycleNotify.didForeground()';
}


}




/// @nodoc


class RouteLifecycleNotifyDidPop extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidPop({required this.route, required this.previousRoute}): super._();
  

 final  Route<dynamic> route;
 final  Route<dynamic>? previousRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidPopCopyWith<RouteLifecycleNotifyDidPop> get copyWith => _$RouteLifecycleNotifyDidPopCopyWithImpl<RouteLifecycleNotifyDidPop>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidPop&&(identical(other.route, route) || other.route == route)&&(identical(other.previousRoute, previousRoute) || other.previousRoute == previousRoute));
}


@override
int get hashCode => Object.hash(runtimeType,route,previousRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didPop(route: $route, previousRoute: $previousRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidPopCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidPopCopyWith(RouteLifecycleNotifyDidPop value, $Res Function(RouteLifecycleNotifyDidPop) _then) = _$RouteLifecycleNotifyDidPopCopyWithImpl;
@useResult
$Res call({
 Route<dynamic> route, Route<dynamic>? previousRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidPopCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidPopCopyWith<$Res> {
  _$RouteLifecycleNotifyDidPopCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidPop _self;
  final $Res Function(RouteLifecycleNotifyDidPop) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? route = null,Object? previousRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidPop(
route: null == route ? _self.route : route // ignore: cast_nullable_to_non_nullable
as Route<dynamic>,previousRoute: freezed == previousRoute ? _self.previousRoute : previousRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidPush extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidPush({required this.route, required this.previousRoute}): super._();
  

 final  Route<dynamic> route;
 final  Route<dynamic>? previousRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidPushCopyWith<RouteLifecycleNotifyDidPush> get copyWith => _$RouteLifecycleNotifyDidPushCopyWithImpl<RouteLifecycleNotifyDidPush>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidPush&&(identical(other.route, route) || other.route == route)&&(identical(other.previousRoute, previousRoute) || other.previousRoute == previousRoute));
}


@override
int get hashCode => Object.hash(runtimeType,route,previousRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didPush(route: $route, previousRoute: $previousRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidPushCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidPushCopyWith(RouteLifecycleNotifyDidPush value, $Res Function(RouteLifecycleNotifyDidPush) _then) = _$RouteLifecycleNotifyDidPushCopyWithImpl;
@useResult
$Res call({
 Route<dynamic> route, Route<dynamic>? previousRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidPushCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidPushCopyWith<$Res> {
  _$RouteLifecycleNotifyDidPushCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidPush _self;
  final $Res Function(RouteLifecycleNotifyDidPush) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? route = null,Object? previousRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidPush(
route: null == route ? _self.route : route // ignore: cast_nullable_to_non_nullable
as Route<dynamic>,previousRoute: freezed == previousRoute ? _self.previousRoute : previousRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidRemove extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidRemove({required this.route, required this.previousRoute}): super._();
  

 final  Route<dynamic> route;
 final  Route<dynamic>? previousRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidRemoveCopyWith<RouteLifecycleNotifyDidRemove> get copyWith => _$RouteLifecycleNotifyDidRemoveCopyWithImpl<RouteLifecycleNotifyDidRemove>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidRemove&&(identical(other.route, route) || other.route == route)&&(identical(other.previousRoute, previousRoute) || other.previousRoute == previousRoute));
}


@override
int get hashCode => Object.hash(runtimeType,route,previousRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didRemove(route: $route, previousRoute: $previousRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidRemoveCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidRemoveCopyWith(RouteLifecycleNotifyDidRemove value, $Res Function(RouteLifecycleNotifyDidRemove) _then) = _$RouteLifecycleNotifyDidRemoveCopyWithImpl;
@useResult
$Res call({
 Route<dynamic> route, Route<dynamic>? previousRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidRemoveCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidRemoveCopyWith<$Res> {
  _$RouteLifecycleNotifyDidRemoveCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidRemove _self;
  final $Res Function(RouteLifecycleNotifyDidRemove) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? route = null,Object? previousRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidRemove(
route: null == route ? _self.route : route // ignore: cast_nullable_to_non_nullable
as Route<dynamic>,previousRoute: freezed == previousRoute ? _self.previousRoute : previousRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidReplace extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidReplace({required this.newRoute, required this.oldRoute}): super._();
  

 final  Route<dynamic>? newRoute;
 final  Route<dynamic>? oldRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidReplaceCopyWith<RouteLifecycleNotifyDidReplace> get copyWith => _$RouteLifecycleNotifyDidReplaceCopyWithImpl<RouteLifecycleNotifyDidReplace>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidReplace&&(identical(other.newRoute, newRoute) || other.newRoute == newRoute)&&(identical(other.oldRoute, oldRoute) || other.oldRoute == oldRoute));
}


@override
int get hashCode => Object.hash(runtimeType,newRoute,oldRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didReplace(newRoute: $newRoute, oldRoute: $oldRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidReplaceCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidReplaceCopyWith(RouteLifecycleNotifyDidReplace value, $Res Function(RouteLifecycleNotifyDidReplace) _then) = _$RouteLifecycleNotifyDidReplaceCopyWithImpl;
@useResult
$Res call({
 Route<dynamic>? newRoute, Route<dynamic>? oldRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidReplaceCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidReplaceCopyWith<$Res> {
  _$RouteLifecycleNotifyDidReplaceCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidReplace _self;
  final $Res Function(RouteLifecycleNotifyDidReplace) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? newRoute = freezed,Object? oldRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidReplace(
newRoute: freezed == newRoute ? _self.newRoute : newRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,oldRoute: freezed == oldRoute ? _self.oldRoute : oldRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidStartUserGesture extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidStartUserGesture({required this.route, required this.previousRoute}): super._();
  

 final  Route<dynamic> route;
 final  Route<dynamic>? previousRoute;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RouteLifecycleNotifyDidStartUserGestureCopyWith<RouteLifecycleNotifyDidStartUserGesture> get copyWith => _$RouteLifecycleNotifyDidStartUserGestureCopyWithImpl<RouteLifecycleNotifyDidStartUserGesture>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidStartUserGesture&&(identical(other.route, route) || other.route == route)&&(identical(other.previousRoute, previousRoute) || other.previousRoute == previousRoute));
}


@override
int get hashCode => Object.hash(runtimeType,route,previousRoute);

@override
String toString() {
  return 'RouteLifecycleNotify.didStartUserGesture(route: $route, previousRoute: $previousRoute)';
}


}

/// @nodoc
abstract mixin class $RouteLifecycleNotifyDidStartUserGestureCopyWith<$Res> implements $RouteLifecycleNotifyCopyWith<$Res> {
  factory $RouteLifecycleNotifyDidStartUserGestureCopyWith(RouteLifecycleNotifyDidStartUserGesture value, $Res Function(RouteLifecycleNotifyDidStartUserGesture) _then) = _$RouteLifecycleNotifyDidStartUserGestureCopyWithImpl;
@useResult
$Res call({
 Route<dynamic> route, Route<dynamic>? previousRoute
});




}
/// @nodoc
class _$RouteLifecycleNotifyDidStartUserGestureCopyWithImpl<$Res>
    implements $RouteLifecycleNotifyDidStartUserGestureCopyWith<$Res> {
  _$RouteLifecycleNotifyDidStartUserGestureCopyWithImpl(this._self, this._then);

  final RouteLifecycleNotifyDidStartUserGesture _self;
  final $Res Function(RouteLifecycleNotifyDidStartUserGesture) _then;

/// Create a copy of RouteLifecycleNotify
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? route = null,Object? previousRoute = freezed,}) {
  return _then(RouteLifecycleNotifyDidStartUserGesture(
route: null == route ? _self.route : route // ignore: cast_nullable_to_non_nullable
as Route<dynamic>,previousRoute: freezed == previousRoute ? _self.previousRoute : previousRoute // ignore: cast_nullable_to_non_nullable
as Route<dynamic>?,
  ));
}


}

/// @nodoc


class RouteLifecycleNotifyDidStopUserGesture extends RouteLifecycleNotify {
  const RouteLifecycleNotifyDidStopUserGesture(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RouteLifecycleNotifyDidStopUserGesture);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RouteLifecycleNotify.didStopUserGesture()';
}


}




// dart format on
